/**
* Generated by Kubb (https://kubb.dev/).
* Do not edit manually.
*/

import { applicationStateOperationSchema } from "./applicationStateOperationSchema.ts";
import { avmValueSchema } from "./avmValueSchema.ts";
import { scratchChangeSchema } from "./scratchChangeSchema.ts";
import { z } from "zod";

/**
 * @description The set of trace information and effect from evaluating a single opcode.
 */
export const simulationOpcodeTraceUnitSchema = z.object({
    "pc": z.number().int().describe("The program counter of the current opcode being evaluated."),
"scratch-changes": z.array(z.lazy(() => scratchChangeSchema).describe("A write operation into a scratch slot.")).describe("The writes into scratch slots.").optional(),
"spawned-inners": z.array(z.number().int()).describe("The indexes of the traces for inner transactions spawned by this opcode, if any.").optional(),
"stack-additions": z.array(z.lazy(() => avmValueSchema).describe("Represents an AVM value.")).describe("The values added by this opcode to the stack.").optional(),
"stack-pop-count": z.number().int().describe("The number of deleted stack values by this opcode.").optional(),
"state-changes": z.array(z.lazy(() => applicationStateOperationSchema).describe("An operation against an application's global/local/box state.")).describe("The operations against the current application's states.").optional()
    }).describe("The set of trace information and effect from evaluating a single opcode.")

export type SimulationOpcodeTraceUnitSchema = z.infer<typeof simulationOpcodeTraceUnitSchema>