/**
* Generated by Kubb (https://kubb.dev/).
* Do not edit manually.
*/

import { accountStateDeltaSchema } from "./accountStateDeltaSchema.ts";
import { stateDeltaSchema } from "./stateDeltaSchema.ts";
import { transactionApplicationSchema } from "./transactionApplicationSchema.ts";
import { transactionAssetConfigSchema } from "./transactionAssetConfigSchema.ts";
import { transactionAssetFreezeSchema } from "./transactionAssetFreezeSchema.ts";
import { transactionAssetTransferSchema } from "./transactionAssetTransferSchema.ts";
import { transactionHeartbeatSchema } from "./transactionHeartbeatSchema.ts";
import { transactionKeyregSchema } from "./transactionKeyregSchema.ts";
import { transactionPaymentSchema } from "./transactionPaymentSchema.ts";
import { transactionSignatureSchema } from "./transactionSignatureSchema.ts";
import { transactionStateProofSchema } from "./transactionStateProofSchema.ts";
import { z } from "zod";

/**
 * @description Contains all fields common to all transactions and serves as an envelope to all transactions type. Represents both regular and inner transactions.\n\nDefinition:\ndata/transactions/signedtxn.go : SignedTxn\ndata/transactions/transaction.go : Transaction\n
 */
export const transactionSchema = z.object({
    "application-transaction": z.lazy(() => transactionApplicationSchema).describe("Fields for application transactions.\n\nDefinition:\ndata/transactions/application.go : ApplicationCallTxnFields").optional(),
"asset-config-transaction": z.lazy(() => transactionAssetConfigSchema).describe("Fields for asset allocation, re-configuration, and destruction.\n\n\nA zero value for asset-id indicates asset creation.\nA zero value for the params indicates asset destruction.\n\nDefinition:\ndata/transactions/asset.go : AssetConfigTxnFields").optional(),
"asset-freeze-transaction": z.lazy(() => transactionAssetFreezeSchema).describe("Fields for an asset freeze transaction.\n\nDefinition:\ndata/transactions/asset.go : AssetFreezeTxnFields").optional(),
"asset-transfer-transaction": z.lazy(() => transactionAssetTransferSchema).describe("Fields for an asset transfer transaction.\n\nDefinition:\ndata/transactions/asset.go : AssetTransferTxnFields").optional(),
"auth-addr": z.string().describe("\\[sgnr\\] this is included with signed transactions when the signing address does not equal the sender. The backend can use this to ensure that auth addr is equal to the accounts auth addr.").optional(),
"close-rewards": z.number().int().describe("\\[rc\\] rewards applied to close-remainder-to account.").optional(),
"closing-amount": z.number().int().describe("\\[ca\\] closing amount for transaction.").optional(),
"confirmed-round": z.number().int().describe("Round when the transaction was confirmed.").optional(),
"created-application-index": z.number().int().describe("Specifies an application index (ID) if an application was created with this transaction.").optional(),
"created-asset-index": z.number().int().describe("Specifies an asset index (ID) if an asset was created with this transaction.").optional(),
"fee": z.number().int().describe("\\[fee\\] Transaction fee."),
"first-valid": z.number().int().describe("\\[fv\\] First valid round for this transaction."),
"genesis-hash": z.string().regex(/^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/).describe("\\[gh\\] Hash of genesis block.").optional(),
"genesis-id": z.string().describe("\\[gen\\] genesis block ID.").optional(),
"global-state-delta": z.lazy(() => stateDeltaSchema).describe("Application state delta.").optional(),
"group": z.string().regex(/^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/).describe("\\[grp\\] Base64 encoded byte array of a sha512/256 digest. When present indicates that this transaction is part of a transaction group and the value is the sha512/256 hash of the transactions in that group.").optional(),
"heartbeat-transaction": z.lazy(() => transactionHeartbeatSchema).describe("Fields for a heartbeat transaction.\n\nDefinition:\ndata/transactions/heartbeat.go : HeartbeatTxnFields").optional(),
"id": z.string().describe("Transaction ID").optional(),
"inner-txns": z.array(z.lazy(() => transactionSchema).describe("Contains all fields common to all transactions and serves as an envelope to all transactions type. Represents both regular and inner transactions.\n\nDefinition:\ndata/transactions/signedtxn.go : SignedTxn\ndata/transactions/transaction.go : Transaction\n")).describe("Inner transactions produced by application execution.").optional(),
"intra-round-offset": z.number().int().describe("Offset into the round where this transaction was confirmed.").optional(),
"keyreg-transaction": z.lazy(() => transactionKeyregSchema).describe("Fields for a keyreg transaction.\n\nDefinition:\ndata/transactions/keyreg.go : KeyregTxnFields").optional(),
"last-valid": z.number().int().describe("\\[lv\\] Last valid round for this transaction."),
"lease": z.string().regex(/^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/).describe("\\[lx\\] Base64 encoded 32-byte array. Lease enforces mutual exclusion of transactions.  If this field is nonzero, then once the transaction is confirmed, it acquires the lease identified by the (Sender, Lease) pair of the transaction until the LastValid round passes.  While this transaction possesses the lease, no other transaction specifying this lease can be confirmed.").optional(),
"local-state-delta": z.array(z.lazy(() => accountStateDeltaSchema).describe("Application state delta.")).describe("\\[ld\\] Local state key/value changes for the application being executed by this transaction.").optional(),
"logs": z.array(z.string().regex(/^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/)).describe("\\[lg\\] Logs for the application being executed by this transaction.").optional(),
"note": z.string().regex(/^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/).describe("\\[note\\] Free form data.").optional(),
"payment-transaction": z.lazy(() => transactionPaymentSchema).describe("Fields for a payment transaction.\n\nDefinition:\ndata/transactions/payment.go : PaymentTxnFields").optional(),
"receiver-rewards": z.number().int().describe("\\[rr\\] rewards applied to receiver account.").optional(),
"rekey-to": z.string().describe("\\[rekey\\] when included in a valid transaction, the accounts auth addr will be updated with this value and future signatures must be signed with the key represented by this address.").optional(),
"round-time": z.number().int().describe("Time when the block this transaction is in was confirmed.").optional(),
"sender": z.string().describe("\\[snd\\] Sender's address."),
"sender-rewards": z.number().int().describe("\\[rs\\] rewards applied to sender account.").optional(),
"signature": z.lazy(() => transactionSignatureSchema).describe("Validation signature associated with some data. Only one of the signatures should be provided.").optional(),
"state-proof-transaction": z.lazy(() => transactionStateProofSchema).describe("Fields for a state proof transaction. \n\nDefinition:\ndata/transactions/stateproof.go : StateProofTxnFields").optional(),
"tx-type": z.enum(["pay", "keyreg", "acfg", "axfer", "afrz", "appl", "stpf", "hb"]).describe("\\[type\\] Indicates what type of transaction this is. Different types have different fields.\n\nValid types, and where their fields are stored:\n* \\[pay\\] payment-transaction\n* \\[keyreg\\] keyreg-transaction\n* \\[acfg\\] asset-config-transaction\n* \\[axfer\\] asset-transfer-transaction\n* \\[afrz\\] asset-freeze-transaction\n* \\[appl\\] application-transaction\n* \\[stpf\\] state-proof-transaction\n* \\[hb\\] heartbeat-transaction")
    }).describe("Contains all fields common to all transactions and serves as an envelope to all transactions type. Represents both regular and inner transactions.\n\nDefinition:\ndata/transactions/signedtxn.go : SignedTxn\ndata/transactions/transaction.go : Transaction\n")

export type TransactionSchema = z.infer<typeof transactionSchema>